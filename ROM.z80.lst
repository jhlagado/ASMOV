0000                          .ENGINE   mycomputer   
0000                             ; 
0000                TEC_1:    EQU   1   
0000                RC2014:   EQU   0   
0000                EXTENDED:   EQU   0   
0000                          IF   RC2014   
                                 ; Configuration for RC2014
                    ROMSTART:   EQU   $8000   
                    RAMSTART:   EQU   $8800   
                    LOADER:   EQU   0   
                    BITBANG:   EQU   0   
0000                          ENDIF      
0000                          IF   TEC_1   
0000                             ; Configuration for TEC-1
0000                LOADER:   EQU   0   
0000                BITBANG:   EQU   0   
0000                ROMSTART:   EQU   $0000   
0000                RAMSTART:   EQU   $2000   ; TODO: set this to TEC 1G
0000                ROMSIZE:   EQU   $2000   
0000                RAMSIZE:   EQU   $2000   
0000                             ;TEC-1D SC 8k rom/ram
0000                             ; ROMSTART .equ $0000
0000                             ; RAMSTART .equ $2000
0000                             ; ROMSIZE  .equ 8192
0000                             ; RAMSIZE  .equ 8192
0000                          ENDIF      
0000                             ; ROM code
0000                             ; Targets:
0000                             ; TEC-1,TEC-1D,TEC-1F,Southern Cross,RC2014
0000                             ; Memory Map: 2k ROM/RAM, 8K ROM/RAM, RC2014
0000                             ; Serial: Bit Bang, 6850 ACIA
0000                             ; 
0000                          IF   TEC_1   
0000                          IF   BITBANG   
                                 ; 
                                 ; bit bang baud rate constants @ 4MHz
                    B300:     EQU   0220H   
                    B1200:    EQU   0080H   
                    B2400:    EQU   003FH   
                    B4800:    EQU   001BH   
                    B9600:    EQU   000BH   
                                 ; 
0000                          ELSE      ;6850
0000                             ; 
0000                             ; 
0000                             ; 6850 ACIA registers
0000                             ;----------------------
0000                CONTROL:   EQU   $80   ;(write) 
0000                STATUS:   EQU   $80   ;(read)
0000                TDR:      EQU   $81   ;(write)
0000                RDR:      EQU   $81   ;(read)
0000                             ; 
0000                             ; control register bits
0000                             ;----------------------
0000                             ; 
0000                             ;clock divisor
0000                             ; 
0000                MRESET:   EQU   $03   ;master reset the ACIA
0000                             ; DIV_0    .EQU  $00        ;CLOCK/1
0000                             ; DIV_16   .EQU  $01        ;CLOCK/16
0000                DIV_64:   EQU   $02   ;CLOCK/64
0000                             ; 
0000                             ; format select
0000                             ; 
0000                F7E2:     EQU   $00   ;7 data bits, EVEN parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7O2:     EQU   $04   ;7 data bits, ODD parity, 2 stop bits (1+7+1+2= 11 bits)
0000                F7E1:     EQU   $08   ;7 data bits, EVEN parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F7O1:     EQU   $0C   ;7 data bits, ODD parity, 1 stop bit (1+7+1+1= 10 bits)
0000                F8N2:     EQU   $10   ;8 data bits, NO parity, 2 stop bits (1+8+0+2= 11 bits)
0000                F8N1:     EQU   $14   ;8 data bits, NO parity, 1 stop bit (1+8+0+1= 10 bits)
0000                F8E1:     EQU   $18   ;8 data bits, EVEN parity, 1 stop bit (1+8+1+1= 11 bits)
0000                F8O1:     EQU   $1C   ;8 data bits, ODD parity,1 stop bit (1+8+1+1= 11 bits)
0000                             ; 
0000                             ; transmitter control
0000                             ; 
0000                RTSLID:   EQU   $00   ;RTS LOW, transmit interrupt disabled
0000                RTSLIE:   EQU   $20   ;RTS LOW, transmit interrupt enabled
0000                RTSHID:   EQU   $40   ;RTS HIGH, transmit interrupt disabled
0000                RTSLIDB:   EQU   $60   ;RTS LOW, transmit interrupt disabled and "break" transmitted
0000                             ; 
0000                             ; receiver interrupt
0000                             ; 
0000                RIE:      EQU   $80   ;receiver interrupt enabled
0000                             ; 
0000                             ; status register bits
0000                             ;---------------------
0000                RDRF:     EQU   0   ;receive data register full
0000                TDRE:     EQU   1   ;transmit data register empty
0000                DCD:      EQU   2   ;data carrier detect
0000                CTS:      EQU   3   ;clear to send
0000                FE:       EQU   4   ;framing error
0000                OVRN:     EQU   5   ;overrun
0000                PE:       EQU   6   ;parity error
0000                IRQ:      EQU   7   ;interrupt request
0000                             ; 
0000                          ENDIF      
0000                          ENDIF      
0000                             ; 
0000                             ; I/O port addresses
0000                             ; 
0000                          IF   TEC_1   
0000                KEYBUF:   EQU   00H   ;MM74C923N KEYBOARD ENCODER
0000                SCAN:     EQU   01H   ;DISPLAY SCAN LATCH
0000                DISPLY:   EQU   02H   ;DISPLAY LATCH
0000                PORT3:    EQU   03H   ;ST3 (8X8), STROBE (RELAY BOARD) DATLATCH (DAT BOARD)
0000                PORT4:    EQU   04H   ;ST4 (8X8), LCD "E" (DAT BOARD)
0000                PORT5:    EQU   05H   
0000                PORT6:    EQU   06H   
0000                PORT7:    EQU   07H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ELSE      ;SC
                    IO0:      EQU   80H   ;IO PORT 0
                    IO1:      EQU   81H   ;IO PORT 1
                    IO2:      EQU   82H   ;IO PORT 2
                    IO3:      EQU   83H   ;IO PORT 3
                    DISPLY:   EQU   84H   ;DISPLAY LATCH
                    SCAN:     EQU   85H   ;DISPLAY SCAN LATCH
                    KEYBUF:   EQU   86H   ;KEYBOARD BUFFER
                    IO7:      EQU   87H   ;ENABLE/DISABLE SINGLE STEPPER (IF INSTALLED)
0000                          ENDIF      
0000                             ; 
0000                             ; ASCII codes
0000                ESC:      EQU   1BH   
0000                CR:       EQU   0DH   
0000                LF:       EQU   0AH   
0000                             ; 
0000                          .ORG   ROMSTART   
0000                             ;reset
0000                RSTVEC:      
0000   C3 8B 00               JP   RESET   
0003                             ;RST 1
0008                          .ORG   ROMSTART+$08   
0008   E5                     PUSH   hl   
0009   2A D0 25               LD   hl,(RST08)   
000C   E3                     EX   (sp),hl   
000D   C9                     RET      
000E                             ; 
000E                             ;RST 2
0010                          .ORG   ROMSTART+$10   
0010   E5                     PUSH   hl   
0011   2A D2 25               LD   hl,(RST10)   
0014   E3                     EX   (sp),hl   
0015   C9                     RET      
0016                             ; 
0016                             ;RST 3
0018                          .ORG   ROMSTART+$18   
0018   E5                     PUSH   hl   
0019   2A D4 25               LD   hl,(RST18)   
001C   E3                     EX   (sp),hl   
001D   C9                     RET      
001E                             ; 
001E                             ;RST 4
0020                          .ORG   ROMSTART+$20   
0020   E5                     PUSH   hl   
0021   2A D6 25               LD   hl,(RST20)   
0024   E3                     EX   (sp),hl   
0025   C9                     RET      
0026                             ; 
0026                             ;RST 5
0028                          .ORG   ROMSTART+$28   
0028   E5                     PUSH   hl   
0029   2A D8 25               LD   hl,(RST28)   
002C   E3                     EX   (sp),hl   
002D   C9                     RET      
002E                             ; 
002E                             ;RST 6
0030                          .ORG   ROMSTART+$30   
0030   E5                     PUSH   hl   
0031   2A DA 25               LD   hl,(RST30)   
0034   E3                     EX   (sp),hl   
0035   ED 4D                  RETI      
0037                             ; 
0037                             ;RST 7 Interrupt
0038                          .ORG   ROMSTART+$38   
0038   E5                     PUSH   hl   
0039   2A DE 25               LD   hl,(INTVEC)   
003C   E3                     EX   (sp),hl   
003D   ED 4D                  RETI      
003F                             ; 
0040                          .ORG   ROMSTART+$40   
0040                             ; 
0040                             ;hexadecimal to 7 segment display code table
0040                          IF   TEC_1   
0040                             ; 
0040                SEVENSEGMENT:      
0040   EB 28 CD AD            DB   0EBH,28H,0CDH,0ADH   ;0,1,2,3
0044   2E A7 E7 29            DB   2EH,0A7H,0E7H,29H   ;4,5,6,7
0048   EF 2F 6F E6            DB   0EFH,2FH,6FH,0E6H   ;8,9,A,B
004C   C3 EC C7 47            DB   0C3H,0ECH,0C7H,47H   ;C,D,E,F
0050                          ELSE      ;SC
                                 ; 
                    SEVENSEGMENT:      
                              DB   3FH,06H,5BH,4FH   ;0,1,2,3
                              DB   66H,6DH,7DH,07H   ;4,5,6,7
                              DB   7FH,6FH,77H,7CH   ;8,9,A,B
                              DB   39H,5EH,79H,71H   ;C,D,E,F
0050                          ENDIF      
0050                             ; 
0050                             ; 
0050                             ;---------------
0050                             ; BIT TIME DELAY
0050                             ;---------------
0050                             ;DELAY FOR ONE SERIAL BIT TIME
0050                             ;ENTRY : HL = DELAY TIME
0050                             ; NO REGISTERS MODIFIED
0050                             ; 
0050                PWRUP:       
0050   21 00 20               LD   hl,$2000   
0053                BITIME:      
0053   E5                     PUSH   HL   
0054   D5                     PUSH   DE   
0055   11 01 00               LD   DE,0001H   
0058                BITIM1:      
0058   ED 52                  SBC   HL,DE   
005A   D2 58 00               JP   NC,BITIM1   
005D   D1                     POP   DE   
005E   E1                     POP   HL   
005F                INTRET:      
005F   C9                     RET      
0060                             ; 
0060                             ;RST 8  Non Maskable Interrupt
0066                          .ORG   ROMSTART+$66   
0066   E5                     PUSH   HL   
0067   2A E0 25               LD   HL,(NMIVEC)   
006A   E9                     JP   (HL)   
006B                             ; 
006B                             ; 
006B                          IF   BITBANG   
                                 ; 
                                 ;------------------------
                                 ; SERIAL TRANSMIT ROUTINE
                                 ;------------------------
                                 ;TRANSMIT BYTE SERIALLY ON DOUT
                                 ; 
                                 ; ENTRY : A = BYTE TO TRANSMIT
                                 ;  EXIT : NO REGISTERS MODIFIED
                                 ; 
                                 ; 
                    TXCHAR:      
                    TXDATA:      
                              PUSH   AF   
                              PUSH   BC   
                              PUSH   HL   
                              LD   HL,(BAUD)   
                              LD   C,A   
                                 ; 
                                 ; TRANSMIT START BIT
                                 ; 
                              XOR   A   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                                 ; 
                                 ; TRANSMIT DATA
                                 ; 
                              LD   B,08H   
                              RRC   C   
                    NXTBIT:      
                              RRC   C   ;SHIFT BITS TO D6,
                              LD   A,C   ;LSB FIRST AND OUTPUT
                              AND   40H   ;THEM FOR ONE BIT TIME.
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              DJNZ   NXTBIT   
                                 ; 
                                 ; SEND STOP BITS
                                 ; 
                              LD   A,40H   
                              OUT   (SCAN),A   
                              CALL   BITIME   
                              CALL   BITIME   
                              POP   HL   
                              POP   BC   
                              POP   AF   
                              RET      
                                 ;-----------------------
                                 ; SERIAL RECEIVE ROUTINE
                                 ;-----------------------
                                 ;RECEIVE SERIAL BYTE FROM DIN
                                 ; 
                                 ; ENTRY : NONE
                                 ;  EXIT : A= RECEIVED BYTE IF CARRY CLEAR
                                 ; 
                                 ; REGISTERS MODIFIED A AND F
                                 ; 
                    RXCHAR:      
                    RXDATA:      
                              PUSH   BC   
                              PUSH   HL   
                                 ; 
                                 ; WAIT FOR START BIT 
                                 ; 
                    RXDAT1:   IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;NO START BIT
                                 ; 
                                 ; DETECTED START BIT
                                 ; 
                              LD   HL,(BAUD)   
                              SRL   H   
                              RR   L   ;DELAY FOR HALF BIT TIME
                              CALL   BITIME   
                              IN   A,(KEYBUF)   
                              BIT   7,A   
                              JR   NZ,RXDAT1   ;START BIT NOT VALID
                                 ; 
                                 ; DETECTED VALID START BIT,READ IN DATA
                                 ; 
                              LD   B,08H   
                    RXDAT2:      
                              LD   HL,(BAUD)   
                              CALL   BITIME   ;DELAY ONE BIT TIME
                              IN   A,(KEYBUF)   
                              RL   A   
                              RR   C   ;SHIFT BIT INTO DATA REG
                              DJNZ   RXDAT2   
                              LD   A,C   
                              OR   A   ;CLEAR CARRY FLAG
                              POP   HL   
                              POP   BC   
                              RET      
                                 ; 
006B                          ELSE      ;6850
006B                             ; 
006B                             ; transmit a character in a
006B                             ;--------------------------
006B                TXDATA:      
006B                TXCHAR:      
006B   C5                     PUSH   bc   
006C   47                     LD   b,a   ;save the character  for later
006D                TXCHAR1:      
006D   DB 80                  IN   a,(STATUS)   ;get the ACIA status
006F   CB 4F                  BIT   1,a   
0071                             ;        bit   TDRE,a                ;is the TDRE bit high?
0071   28 FA                  JR   z,TxChar1   ;no, the TDR is not empty
0073   78                     LD   a,b   ;yes, get the character
0074   D3 81                  OUT   (TDR),a   ;and put it in the TDR
0076   C1                     POP   bc   
0077   C9                     RET      
0078                             ; 
0078                             ; receive  a character in a
0078                             ;---------------------------------
0078                RXDATA:      
0078                RXCHAR:      
0078   DB 80                  IN   a,(STATUS)   ;get the ACIA status
007A   CB 47                  BIT   0,a   
007C                             ;        bit   RDRF,a             ;is the RDRF bit high?
007C   28 FA                  JR   z,RxChar   ;no, the RDR is empty
007E   DB 81                  IN   a,(RDR)   ;yes, read the received char
0080   C9                     RET      
0081                          ENDIF      
0081                             ; 
0081                          IF   LOADER   
                                 ;   .ORG   ROMSTART + $0700
                                 ;-----------------------
                                 ; RECEIVE INTEL HEX FILE
                                 ;-----------------------
                    INTELH:      
                              LD   IX,BUF   
                                 ; 
                                 ; WAIT FOR RECORD MARK
                                 ; 
                    INTEL1:      
                              XOR   A   
                              LD   (IX+3),A   ;CLEAR CHECKSUM
                              CALL   RXDATA   ;WAIT FOR THE RECORD MARK
                              CP   ":"   ;TO BE TRANSMITTED
                              JR   NZ,INTEL1   ;NOT RECORD MARK
                                 ; 
                                 ; GET RECORD LENGTH
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+0),A   ;NUMBER OF DATA BYTES
                                 ; 
                                 ; GET ADDRESS FIELD
                                 ; 
                              CALL   GETBYT   
                              LD   (IX+2),A   ;LOAD ADDRESS HIGH BYTE
                              CALL   GETBYT   
                              LD   (IX+1),A   ;LOAD ADDRESS LOW BYTE
                                 ; 
                                 ; GET RECORD TYPE
                                 ; 
                              CALL   GETBYT   
                              JR   NZ,INTEL4   ;END OF FILE RECORD
                                 ; 
                                 ; READ IN THE DATA
                                 ; 
                              LD   B,(IX+0)   ;NUMBER OF DATA BYTES
                              LD   H,(IX+2)   ;LOAD ADDRESS HIGH BYTE
                              LD   L,(IX+1)   ;LOAD ADDRESS LOW BYTE
                                 ; 
                    INTEL2:      
                              CALL   GETBYT   ;GET DATA BYTE
                              LD   (HL),A   ;STORE DATA BYTE
                              INC   HL   
                              DJNZ   INTEL2   ;LOAD MORE BYTES
                                 ; 
                                 ; GET CHECKSUM AND COMPARE
                                 ; 
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE RECORD CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              JR   Z,INTEL1   ;CHECKSUM OK,NEXT RECORD
                              RET      ;NZ=CHECKSUM ERROR
                                 ; 
                                 ; END OF FILE RECORD
                                 ; 
                    INTEL4:      
                              LD   A,(IX+3)   ;CONVERT CHECKSUM TO
                              NEG      ;TWO'S COMPLEMENT
                              LD   (IX+4),A   ;SAVE COMPUTED CHECKSUM
                              CALL   GETBYT   
                              LD   (IX+3),A   ;SAVE EOF CHECKSUM
                              CP   (IX+4)   ;COMPARE CHECKSUM
                              RET      ;NZ=CHECKSUM ERROR
                                 ;--------------------------
                                 ; GET BYTE FROM SERIAL PORT
                                 ;--------------------------
                    GETBYT:      
                              PUSH   BC   
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT1   
                              ADD   A,09H   
                    GETBT1:      
                              AND   0FH   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              SLA   A   
                              LD   C,A   
                                 ; 
                                 ; GET LOW NYBBLE
                                 ; 
                              CALL   RXDATA   
                              BIT   6,A   
                              JR   Z,GETBT2   
                              ADD   A,09H   
                    GETBT2:   AND   0FH   
                              OR   C   
                              LD   B,A   
                              ADD   A,(IX+3)   
                              LD   (IX+3),A   ;ADD TO CHECKSUM
                              LD   A,B   
                              AND   A   ;CLEAR CARRY
                              POP   BC   
                              RET      
0081                          ENDIF      
0081                             ; 
0081                             ; in this example code just wait for an INTEL Hex file download
0081                             ;just going to send a char to let you know I'm here
0081                          IF   LOADER   
                                 ; 
                    LOAD:        
                              LD   a,"L"   ; L for load
                              CALL   TxChar   
                              CALL   INTELH   
                              JP   z,RAMSTART   ;assume the downloaded code starts here
                              LD   a,"0"   ;0 is false
                              CALL   TxChar   
                              JR   load   ;if at first you don't succeed...
0081                          ENDIF      
0081                             ; 
0081                GETCHAR:      
0081   2A E2 25               LD   HL,(GETCVEC)   
0084   E9                     JP   (HL)   
0085                             ; 
0085                PUTCHAR:      
0085   E5                     PUSH   HL   
0086   2A E4 25               LD   HL,(PUTCVEC)   
0089   E3                     EX   (SP),HL   
008A   C9                     RET      
008B                             ; 
008B                RESET:       
008B   31 00 21               LD   SP,stack   
008E   21 5F 00               LD   HL,IntRet   
0091   22 D0 25               LD   (RST08),HL   
0094   22 D2 25               LD   (RST10),HL   
0097   22 D4 25               LD   (RST18),HL   
009A   22 D6 25               LD   (RST20),HL   
009D   22 D8 25               LD   (RST28),HL   
00A0   22 DA 25               LD   (RST30),HL   
00A3   22 DE 25               LD   (INTVEC),HL   
00A6   22 E0 25               LD   (NMIVEC),HL   
00A9                             ; 
00A9   21 78 00               LD   HL,RXDATA   
00AC   22 E2 25               LD   (GETCVEC),HL   
00AF   21 6B 00               LD   HL,TXDATA   
00B2   22 E4 25               LD   (PUTCVEC),HL   
00B5                             ; 
00B5                          IF   TEC_1   
00B5                          IF   BITBANG = 0   
00B5                             ; 
00B5   3E 03                  LD   a,MRESET   
00B7   D3 80                  OUT   (CONTROL),a   ;reset the ACIA
00B9                             ; 
00B9                          ENDIF      
00B9                          ENDIF      
00B9                             ; 
00B9   CD 50 00               CALL   PWRUP   
00BC   ED 56                  IM   1   
00BE   FB                     EI      
00BF                             ; 
00BF                          IF   TEC_1   
00BF                          IF   BITBANG   
                                 ; 
                                 ;inline serial initialisation
                              LD   A,$40   
                              LD   C,SCAN   
                              OUT   (C),A   
                              LD   HL,B4800   
                              LD   (BAUD),HL   
                                 ; 
00BF                          ELSE      ;6850      
00BF                             ; 
00BF   3E 12                  LD   a,RTSLID+F8N2+DIV_64   
00C1   D3 80                  OUT   (CONTROL),a   ;initialise ACIA  8 bit word, No parity 2 stop divide by 64 for 115200 baud
00C3                             ; 
00C3                          ENDIF      
00C3                          ENDIF      
00C3                             ; 
00C3                             ; 
00C3                             ; 
00C3   31 00 21               LD   sp,STACK   ; start ASMOV
00C6   C3 60 06               JP   start   
00C9                             ; 
00C9                             ; *************************************************************************
00C9                             ; 
00C9                             ;  ASMOV programming language for the Z80
00C9                             ; 
00C9                             ;  by John Hardy 2023
00C9                             ; 
00C9                             ;  GNU GENERAL PUBLIC LICENSE    Version 3, 29 June 2007
00C9                             ; 
00C9                             ;  see the LICENSE file in this repo for more information
00C9                             ; 
00C9                             ;  Incorporating code from the MINT project by Ken Boak and Craig Jones.
00C9                             ; 
00C9                             ; *****************************************************************************
00C9                TRUE:     EQU   -1   ; C-style true
00C9                FALSE:    EQU   0   
00C9                NUL:      EQU   0   ; exit code
00C9                DQ:       EQU   $22   ; " double quote char
00C9                CTRL_C:   EQU   3   
00C9                CTRL_E:   EQU   5   
00C9                CTRL_H:   EQU   8   
00C9                CTRL_J:   EQU   10   
00C9                CTRL_L:   EQU   12   
00C9                CTRL_P:   EQU   16   
00C9                CTRL_S:   EQU   19   
00C9                ESC:      EQU   27   
00C9                             ; macros for inlining a onty function in assembly
00C9                             ; follow immediately with a null terminated block of ASMOV code
00C9                .macro FUNC,name,numLocals,argsStr
00C9                             ; 
00C9                name:
00C9                 call go
00C9                 dw NUL                      ; NUL closure
00C9                 dw name%%M
00C9                 dw $+2
00C9                 db numLocals                ; num_locals
00C9                 .pstr argsStr
00C9                name%%M:
00C9                .endm
00C9                 
00C9                .macro PERFORM,name
00C9                             ; 
00C9                 ld ix,perform%%M
00C9                 jp name
00C9                perform%%M:
00C9                .endm
00C9                 
0180                          .ORG   ROMSTART + $180   ; 0+180 put ASMOV code from here	
0180                             ;********************** PAGE 1 BEGIN *********************************************
0180                             ;********************** PAGE 1 END *********************************************
0180                             ; ***********************************************************************
0180                             ; Initial values for system vars		
0180                             ; ***********************************************************************		
0180                ISYSVARS:      
0180   00 23                  DW   TIB   ; vTIBPtr pointer into TIB
0182   00 24                  DW   BUFFER   ; vBufPtr pointer into BUF
0184   26 26                  DW   HEAP   ; vHeapPtr start of the free mem
0186   00 22                  DW   NAMES   ; vNamesPtr
0188   00 00                  DW   NUL   ; vRecurPtr
018A   02                     DB   2   ; vDataWidth in bytes of array operations (default 1 byte)
018B   0A                     DB   10   ; vNumBase = 10
018C   24                     DB   "$"   ; vHexPrefix
018D   FF                     DB   TRUE   ; vEcho
018E   00                     DB   FALSE   ; vStrMode
018F   00                     DB   0   
0190   00                     DB   0   
0191   00                     DB   0   
0192                             ; **********************************************************************			
0192                             ; title string (also used by warm boot)
0192                             ; **********************************************************************
0192                TITLESTR:      
0192   1B 5B 32 4A 41 53 4D 4F 56 20 56 30 2E 31 0D 0A 00 00 00 00 .CSTR   ESC,"[2JASMOV V0.1\r\n",0,0,0   
01A6                             ;********************** PAGE 2 BEGIN ***********************************
01A6                          ALIGN   $100   
0200                PEARSON:      
0200   CE 00 73 16 01 40 6F 2F 57 4E 41 0D 2D 2E 15 02 64 7E 0B 53 20 04 72 47 39 08 26 33 38 3D 54 1B DB   206,0,115,22,1,64,111,47,87,78,65,13,45,46,21,2,100,126,11,83,32,4,114,71,57,8,38,51,56,61,84,27   
0220   1E 71 1A 7A 48 4A 32 18 31 5D 49 21 2B E4 D4 D7 66 4C BD B2 5F 27 42 EF B6 DD 0C 6B AC 67 F5 C3 DB   30,113,26,122,72,74,50,24,49,93,73,33,43,228,212,215,102,76,189,178,95,39,66,239,182,221,12,107,172,103,245,195   
0240   BE 3E 6D B4 24 79 B8 58 46 9D 0E 0A 44 A3 AF C6 E5 C2 12 5C 85 A8 A5 3B 90 7F EB 19 8D 55 C5 F2 DB   190,62,109,180,36,121,184,88,70,157,14,10,68,163,175,198,229,194,18,92,133,168,165,59,144,127,235,25,141,85,197,242   
0260   88 FA 43 29 1D 52 B1 DF 07 09 D3 97 11 5B 22 7B 5A 1F 45 DC C9 3C 84 2C DB FE D5 03 B5 CB EA 0F DB   136,250,67,41,29,82,177,223,7,9,211,151,17,91,34,123,90,31,69,220,201,60,132,44,219,254,213,3,181,203,234,15   
0280   50 E6 34 6C F0 76 62 D0 7C D8 06 61 35 DE 10 65 1C 69 E8 74 83 4D 36 3A E9 4B 14 68 23 CF 60 BC DB   80,230,52,108,240,118,98,208,124,216,6,97,53,222,16,101,28,105,232,116,131,77,54,58,233,75,20,104,35,207,96,188   
02A0   3F C8 30 BF 98 56 8B 59 8C F7 CC 28 4F 7D 17 FF 13 6A C7 05 51 37 70 77 BB 75 63 6E A7 25 C1 2A DB   63,200,48,191,152,86,139,89,140,247,204,40,79,125,23,255,19,106,199,5,81,55,112,119,187,117,99,110,167,37,193,42   
02C0   94 78 A6 5E F6 FD CA 8E F9 9F 80 D1 8F D6 C4 C0 FB 81 DA CD A2 96 A1 D2 ED 82 EC F4 F8 87 8A E0 DB   148,120,166,94,246,253,202,142,249,159,128,209,143,214,196,192,251,129,218,205,162,150,161,210,237,130,236,244,248,135,138,224   
02E0   FC EE E7 BA E1 A0 E2 B0 95 9A F3 E3 D9 92 AA F1 AD 9B AB A4 86 B7 99 9E A9 AE 93 91 B9 9C 89 B3 DB   252,238,231,186,225,160,226,176,149,154,243,227,217,146,170,241,173,155,171,164,134,183,153,158,169,174,147,145,185,156,137,179   
0300                OPCODES:      
0300   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 DB   set_,add_,0,srl_,0,0,0,ccf_,0,0,0,0,0,0,0,sll_,rra_,0,0,0,0,0,adc_,0,0,0,0,0,0,im_,0,0   
0320   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 01 00 00 00 DB   0,0,0,0,0,retn_,0,0,0,0,0,0,0,0,0,0,sbc_,0,0,cpd_,0,rrc_,0,0,indr_,0,0,pop_,ld_,0,cpdr_,0   
0340   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 DB   0,0,rst_,0,scf_,sla_,0,djnz_,0,ex_,call_,0,exx_,sub_,or_,0,0,0,0,cpl_,0,0,0,0,0,0,0,res_,0,rl_,otdr_,0   
0360   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 DB   outd_,rrd_,0,reti_,0,0,0,bit_,0,0,0,ei_,0,0,ind_,0,ini_,0,cpi_,inir_,outi_,0,0,0,0,0,xor_,0,0,0,0,cp_   
0380   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 DB   0,0,0,rlca_,sra_,rrca_,0,0,0,0,0,0,0,0,0,0,ldd_,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   
03A0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 DB   otir_,0,daa_,0,halt_,0,0,inc_,ldi_,0,0,0,rla_,push_,0,0,and_,0,0,0,0,0,0,0,0,0,0,dec_,0,0,0,jp_   
03C0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 DB   0,0,0,neg_,0,0,0,0,jr_,di_,0,0,0,nop_,cpir_,0,0,0,0,ret_,0,0,0,0,0,0,0,0,0,rld_,0,in_   
03E0   00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 DB   0,0,0,0,0,0,0,lddr_,0,0,0,0,ldir_,0,0,rr_,0,0,0,0,0,rlc_,0,0,0,0,out_,0,0,0,0,0   
0400                          ALIGN   $100   
0400                PAGE4:       
0400                RLA_:        
0400                OUTI_:       
0400                INDR_:       
0400                IND_:        
0400                RL_:         
0400                CP_:         
0400                EX_:         
0400                IN_:         
0400                EI_:         
0400                INC_:        
0400                LDIR_:       
0400                DEC_:        
0400                ADD_:        
0400                SLA_:        
0400                EXX_:        
0400                RRC_:        
0400                OR_:         
0400                IM_:         
0400                OTDR_:       
0400                DI_:         
0400                JR_:         
0400                SRA_:        
0400                NEG_:        
0400                CCF_:        
0400                AND_:        
0400                RES_:        
0400                CPDR_:       
0400                SCF_:        
0400                RST_:        
0400                POP_:        
0400                RETI_:       
0400                LDD_:        
0400                OUTD_:       
0400                RRD_:        
0400                ADC_:        
0400                RETN_:       
0400                RLC_:        
0400                SUB_:        
0400                CPI_:        
0400                CALL_:       
0400                OUT_:        
0400                XOR_:        
0400                RLD_:        
0400                DJNZ_:       
0400                CPIR_:       
0400                SET_:        
0400                PUSH_:       
0400                INI_:        
0400                RRA_:        
0400                BIT_:        
0400                LDDR_:       
0400                SLL_:        
0400                DAA_:        
0400                OTIR_:       
0400                CPD_:        
0400                RRCA_:       
0400                INIR_:       
0400                CPL_:        
0400                RR_:         
0400                JP_:         
0400                HALT_:       
0400                SBC_:        
0400                NOP_:        
0400                RLCA_:       
0400                RET_:        
0400                SRL_:        
0400                LDI_:        
0400   C9                     RET      
0401                LD_:         
0401   C9                     RET      
0402                             ;********************** PAGE 2 END *********************************************
0402                          ALIGN   $100   
0500                             ;********************** PAGE 3 BEGIN *********************************************
0500                             ;********************** PAGE 3 END *********************************************
0500                          ALIGN   $100   
0500                             ;********************** PAGE 4 BEGIN *********************************************
0500                             ; ;                               67
0500                             ; dot:
0500                             ; print:
0500                             ;     inc bc
0500                             ;     ld a,(bc)
0500                             ;     cp "a"                      ; .a print array
0500                             ;     jr z,printArray
0500                             ;     cp "c"                      ; .c print char
0500                             ;     jr z,printChar
0500                             ;     cp "s"                      ; .s print string
0500                             ;     jr z,printString
0500                             ;     dec bc
0500                             ;     jr printNumber              ; .  print number, fall through
0500                             ; printArray:                     ; TODO
0500                             ;     jp dotNext
0500                             ; ; .c print char
0500                             ; ; char --
0500                             ; printChar:
0500                             ;     pop hl                      ; a = char
0500                             ;     ld a,l
0500                             ;     ld de,(vBufPtr)             ; de = buffer*
0500                             ;     ld (de),a
0500                             ;     inc de
0500                             ;     ld (vBufPtr),de             ; save buffer*'
0500                             ;     jp dotNext
0500                             ; ; .s print string
0500                             ; ; string* --
0500                             ; printString:
0500                             ;     pop hl                      ; hl = string*
0500                             ;     ld de,(vBufPtr)             ; de = buffer*
0500                             ;     jr printString1
0500                             ; printString0:
0500                             ;     ld (de),a                   ; a -> buffer*
0500                             ;     inc de                      ; string*++,
0500                             ;     inc hl
0500                             ; printString1:
0500                             ;     ld a,(hl)                   ; a <- string*
0500                             ;     or a                        ; if NUL exit loop
0500                             ;     jr nz,printString0
0500                             ;     ld (vBufPtr),de             ; save buffer*' in pointer
0500                             ;     jp dotNext
0500                             ; ; . print decimal
0500                             ; ; value --
0500                             ; printNumber:
0500                             ;     ld a,(vNumBase)
0500                             ;     cp 16
0500                             ;     jp z,printHex              ; else falls through
0500                             ;     jp printDec
0500                             ; ; print decimal                 ; 70
0500                             ; ; value --
0500                             ; printDec:
0500                             ;     ld de,(vBufPtr)             ; de"= buffer* bc" = IP
0500                             ;     exx
0500                             ;     pop hl                      ; hl = value
0500                             ;     ld a,(vDataWidth)
0500                             ;     dec a
0500                             ;     jr nz,printDec1
0500                             ;     ld h,0
0500                             ; printDec1:
0500                             ;     call formatDec
0500                             ;     exx                         ; de = buffer*' bc = IP
0500                             ;     ld a," "                    ; append space to buffer
0500                             ;     ld (de),a
0500                             ;     inc de                      ; string*++,
0500                             ;     ld (vBufPtr),de             ; update buffer* with buffer*'
0500                             ;     jp dotNext
0500                             ; ; buffer hex                    37
0500                             ; ; value --
0500                             ; printHex:
0500                             ;     ld de,(vBufPtr)
0500                             ;     ld a,(vHexPrefix)           ; "$"
0500                             ;     or a                        ; skip if null
0500                             ;     jr z,printHex1
0500                             ;     ld (de),a
0500                             ;     inc de                      ; string*++,
0500                             ; printHex1:
0500                             ;     pop hl                      ; hl = value
0500                             ;     ld a,(vDataWidth)
0500                             ;     dec a
0500                             ;     jr z,printHex2
0500                             ;     ld a,h
0500                             ;     call printHex3
0500                             ; printHex2:
0500                             ;     ld a,l
0500                             ;     call printHex3
0500                             ;     ld a," "                    ; append space to buffer
0500                             ;     ld (de),a
0500                             ;     inc de                      ; string*++,
0500                             ;     ld (vBufPtr),de
0500                             ;     jp dotNext
0500                             ; printHex3:		
0500                             ;     push af
0500                             ; 	rra
0500                             ; 	rra
0500                             ; 	rra
0500                             ; 	rra
0500                             ;     call printHex4
0500                             ;     pop af
0500                             ; printHex4:		
0500                             ;     and	0x0F
0500                             ; 	add	a,0x90
0500                             ; 	daa
0500                             ; 	adc	a,0x40
0500                             ; 	daa
0500                             ; 	ld (de),a
0500                             ;     inc de                      ; string*++,
0500                             ; 	ret
0500                             ;********************** PAGE 4 END *********************************************
0500                          ALIGN   $100   
0500                             ;********************** PAGE 5 BEGIN *********************************************
0500                             ;********************** PAGE 5 END *********************************************
0500                             ;********************** PAGE 6 BEGIN *********************************************
0500                             ;********************** PAGE 6 END *********************************************
0500                          ALIGN   $100   
0500                             ;********************** PAGE 7 BEGIN *********************************************
0500                             ; 0..9 number                   37
0500                NUM:         
0500   21 00 00               LD   hl,$0000   ; Clear hl to accept the number
0503   0A                     LD   a,(bc)   ; Get numeral or -
0504   FE 2D                  CP   "-"   
0506   20 01                  JR   nz,num0   
0508   03                     INC   bc   ; move to next char, no flags affected
0509                NUM0:        
0509   08                     EX   af,af'   ; save zero flag = 0 for later
050A                NUM1:        
050A   0A                     LD   a,(bc)   ; read digit
050B   D6 30                  SUB   "0"   ; less than 0?
050D   38 13                  JR   c,num2   ; not a digit, exit loop
050F   FE 0A                  CP   10   ; greater that 9?
0511   30 0F                  JR   nc,num2   ; not a digit, exit loop
0513   03                     INC   bc   ; inc IP
0514   54 5D                  LD   de,hl   ; multiply hl * 10
0516   29                     ADD   hl,hl   
0517   29                     ADD   hl,hl   
0518   19                     ADD   hl,de   
0519   29                     ADD   hl,hl   
051A   85                     ADD   a,l   ; add digit in a to hl
051B   6F                     LD   l,a   
051C   3E 00                  LD   a,0   
051E   8C                     ADC   a,h   
051F   67                     LD   h,a   
0520   18 E8                  JR   num1   
0522                NUM2:        
0522   0B                     DEC   bc   
0523   08                     EX   af,af'   ; restore zero flag
0524   20 07                  JR   nz,num3   
0526   EB                     EX   de,hl   ; negate the value of hl
0527   21 00 00               LD   hl,0   
052A   B7                     OR   a   ; jump to sub2
052B   ED 52                  SBC   hl,de   
052D                NUM3:        
052D   E5                     PUSH   hl   ; Put the number on the stack
052E   DD E9                  JP   (ix)   ; and process the next character
0530                             ;*******************************************************************
0530                             ; general routines
0530                             ;*******************************************************************
0530                PUTSTR0:      
0530   CD 85 00               CALL   putchar   
0533   23                     INC   hl   
0534                PUTSTR:      
0534   7E                     LD   a,(hl)   
0535   B7                     OR   a   
0536   20 F8                  JR   nz,putstr0   
0538   C9                     RET      
0539                             ; hl = value
0539                             ; de = buffer*
0539                             ; a, bc, de, hl destroyed
0539                FORMATDEC0:      
0539   E5                     PUSH   hl   
053A   D9                     EXX      
053B   E1                     POP   hl   
053C                             ; hl = value
053C                             ; de' = buffer*
053C                             ; a, bc, de, hl destroyed
053C                FORMATDEC:      
053C   CB 7C                  BIT   7,h   
053E   28 0C                  JR   z,formatDec2   
0540   D9                     EXX      
0541   3E 2D                  LD   a,"-"   
0543   12                     LD   (de),a   
0544   13                     INC   de   
0545   D9                     EXX      
0546   AF                     XOR   a   
0547   95                     SUB   l   
0548   6F                     LD   l,a   
0549   9F                     SBC   a,a   
054A   94                     SUB   h   
054B   67                     LD   h,a   
054C                FORMATDEC2:      
054C   0E 00                  LD   c,0   ; leading zeros flag = false
054E   11 F0 D8               LD   de,-10000   
0551   CD 6C 05               CALL   formatDec4   
0554   11 18 FC               LD   de,-1000   
0557   CD 6C 05               CALL   formatDec4   
055A   11 9C FF               LD   de,-100   
055D   CD 6C 05               CALL   formatDec4   
0560   1E F6                  LD   e,-10   
0562   CD 6C 05               CALL   formatDec4   
0565   0C                     INC   c   ; flag = true for at least digit
0566   1E FF                  LD   e,-1   
0568   CD 6C 05               CALL   formatDec4   
056B   C9                     RET      
056C                FORMATDEC4:      
056C   06 2F                  LD   b,"0"-1   
056E                FORMATDEC5:      
056E   04                     INC   b   
056F   19                     ADD   hl,de   
0570   38 FC                  JR   c,formatDec5   
0572   ED 52                  SBC   hl,de   
0574   3E 30                  LD   a,"0"   
0576   B8                     CP   b   
0577   20 05                  JR   nz,formatDec6   
0579   AF                     XOR   a   
057A   B1                     OR   c   
057B   C8                     RET   z   
057C   18 01                  JR   formatDec7   
057E                FORMATDEC6:      
057E   0C                     INC   c   
057F                FORMATDEC7:      
057F   78                     LD   a,b   
0580   D9                     EXX      
0581   12                     LD   (de),a   
0582   13                     INC   de   
0583   D9                     EXX      
0584   C9                     RET      
0585                             ; **************************************************************************
0585                             ; calculate nesting value
0585                             ; a is char to be tested,
0585                             ; e is the nesting value (initially 0)
0585                             ; e is increased by ( and [
0585                             ; e is decreased by ) and ]
0585                             ; e has its bit 7 toggled by `
0585                             ; limited to 127 levels
0585                             ; **************************************************************************
0585                NESTING:      
0585   FE 27                  CP   "'"   ; quote char
0587   28 0A                  JR   z,nesting0   
0589   FE 22                  CP   DQ   ; double quote char
058B   28 06                  JR   z,nesting0   
058D   FE 60                  CP   "`"   ; grave char
058F   28 02                  JR   z,nesting0   
0591   18 0A                  JR   nesting1   
0593                NESTING0:      
0593   CB 7B                  BIT   7,e   
0595   28 03                  JR   z,nesting1a   
0597   CB BB                  RES   7,e   
0599   C9                     RET      
059A                NESTING1A:      
059A   CB FB                  SET   7,e   
059C   C9                     RET      
059D                NESTING1:      
059D   CB 7B                  BIT   7,e   
059F   C0                     RET   nz   
05A0   FE 7B                  CP   "{"   
05A2   28 08                  JR   z,nesting2   
05A4   FE 5B                  CP   "["   
05A6   28 04                  JR   z,nesting2   
05A8   FE 28                  CP   "("   
05AA   20 02                  JR   nz,nesting3   
05AC                NESTING2:      
05AC   1C                     INC   e   
05AD   C9                     RET      
05AE                NESTING3:      
05AE   FE 7D                  CP   "}"   
05B0   28 07                  JR   z,nesting4   
05B2   FE 5D                  CP   "]"   
05B4   28 03                  JR   z,nesting4   
05B6   FE 29                  CP   ")"   
05B8   C0                     RET   nz   
05B9                NESTING4:      
05B9   1D                     DEC   e   
05BA   C9                     RET      
05BB                PROMPT:      
05BB   CD CB 05               CALL   printStr   
05BE   0D 0A 3E 20 00         .CSTR   "\r\n> "   
05C3   C9                     RET      
05C4                CRLF:        
05C4   CD CB 05               CALL   printStr   
05C7   0D 0A 00               .CSTR   "\r\n"   
05CA   C9                     RET      
05CB                             ; prints a null teminated string
05CB                             ; the string should be immediately following the call
05CB                PRINTSTR:      
05CB   E3                     EX   (sp),hl   ; swap			
05CC   CD 34 05               CALL   putstr   
05CF   23                     INC   hl   ; inc past NUL
05D0   E3                     EX   (sp),hl   ; put it back	
05D1   C9                     RET      
05D2                             ; hl = number to print in decimal
05D2                PRINTNUM:      
05D2   ED 5B E8 25            LD   de,(vBufPtr)   ; de' = buffer*
05D6   CD 39 05               CALL   formatDec0   
05D9   D9                     EXX      ; restore de = buffer*
05DA   3E 00                  LD   a,0   ; append NUL to buffer
05DC   12                     LD   (de),a   
05DD   13                     INC   de   ; string*++,
05DE   ED 53 E8 25            LD   (vBufPtr),de   ; update buffer* with buffer*'
05E2   21 00 24               LD   hl,BUFFER   
05E5   22 E8 25               LD   (vBufPtr),hl   ; reset vBufPtr to vHeapPtr
05E8   C3 34 05               JP   putstr   
05EB                             ; Compares two null terminated strings.
05EB                             ; de = string1* hl = string2* -- bool
05EB                             ; returns: hl = bool
05EB                STRINGCOMPARE:      
05EB                STRINGCOMPARE1:      
05EB   1A                     LD   a,(de)   
05EC   BE                     CP   (hl)   
05ED   20 07                  JR   nz,stringCompare2   
05EF   B7                     OR   a   
05F0   28 09                  JR   z,stringCompare3   
05F2   13                     INC   de   
05F3   23                     INC   hl   
05F4   18 F5                  JR   stringCompare1   
05F6                STRINGCOMPARE2:      
05F6   21 00 00               LD   hl,FALSE   
05F9   18 03                  JR   stringCompare4   
05FB                STRINGCOMPARE3:      
05FB   21 FF FF               LD   hl,TRUE   
05FE                STRINGCOMPARE4:      
05FE   E5                     PUSH   hl   
05FF   C9                     RET      
0600                             ; string length
0600                             ; de = string*
0600                             ; returns: hl = length
0600                STRINGLENGTH:      
0600   21 00 00               LD   hl,0   
0603   18 02                  JR   stringLength2   
0605                STRINGLENGTH1:      
0605   13                     INC   de   
0606   23                     INC   hl   
0607                STRINGLENGTH2:      
0607   1A                     LD   a,(de)   
0608   B7                     OR   a   
0609   20 FA                  JR   nz,stringLength1   
060B                STRINGLENGTH3:      
060B   C9                     RET      
060C                             ; 
060C                             ; ASMOV interpreter
060C                             ; 
060C                INIT:        
060C   21 92 01               LD   hl,titleStr   
060F   11 12 26               LD   de,titleBuf   
0612   06 14                  LD   b,20   
0614                INIT1:       
0614   1A                     LD   a,(de)   
0615   BE                     CP   (hl)   
0616   20 17                  JR   nz,coldBoot0   
0618   13                     INC   de   
0619   23                     INC   hl   
061A   10 F8                  DJNZ   init1   
061C                WARMINIT:      
061C   ED 4B FE 25            LD   bc,(vSavedIP)   ; restore IP
0620   ED 7B 00 26            LD   sp,(vSavedDSP)   ; restore Data SP
0624   FD 2A 02 26            LD   iy,(vSavedRSP)   ; restore Return SP
0628   DD 2A 04 26            LD   ix,(vSavedNext)   ; restore Next
062C   C3 66 06               JP   start1   
062F                COLDBOOT0:      
062F   21 92 01               LD   hl,titleStr   ; copy titleStr to titleBuf
0632   11 12 26               LD   de,titleBuf   
0635   06 14                  LD   b,20   
0637   ED B0                  LDIR      
0639                COLDINIT:      
0639   21 80 01               LD   hl,isysVars   
063C   11 E6 25               LD   de,sysVars   
063F   01 12 00               LD   bc,4 * 2 + 10   
0642   ED B0                  LDIR      
0644   21 00 25               LD   hl,vars   ; 52 vars LO HI
0647   06 34                  LD   b,26*2   
0649   AF                     XOR   a   
064A                COLDBOOT1:      
064A   77                     LD   (hl),a   
064B   23                     INC   hl   
064C   10 FC                  DJNZ   coldBoot1   
064E   DD 21 E2 06            LD   ix,NEXT   
0652   FD 21 00 21            LD   iy,STACK   
0656   C9                     RET      
0657                COLDSTART:      
0657   31 00 21               LD   sp,STACK   
065A   CD 2F 06               CALL   coldBoot0   
065D   C3 66 06               JP   start1   
0660                START:       
0660   31 00 21               LD   sp,STACK   ; start ASMOV
0663   CD 0C 06               CALL   init   ; setups
0666                START1:      
0666   21 12 26               LD   hl,titleBuf   
0669   CD 34 05               CALL   putstr   ; prog count to stack, put code line 235 on stack then call print
066C                INTERPRET:      
066C   CD BB 05               CALL   prompt   
066F   01 00 00               LD   bc,0   ; load TIB length, decide char into tib or execute or control
0672   21 00 23               LD   hl,TIB   
0675   22 E6 25               LD   (vTIBPtr),hl   ; no chars in TIB so set end pointer to beginning
0678                INTERPRET2:      ; calculate nesting
0678   1E 00                  LD   e,0   ; initilize nesting value
067A   C5                     PUSH   bc   ; save offset into TIB,
067B                             ; bc is also the count of chars in TIB
067B   21 00 23               LD   hl,TIB   ; hl is start of TIB
067E   18 06                  JR   interpret4   
0680                INTERPRET3:      
0680   7E                     LD   a,(hl)   ; a = char in TIB
0681   23                     INC   hl   ; inc pointer into TIB
0682   0B                     DEC   bc   ; dec count of chars in TIB
0683   CD 85 05               CALL   nesting   ; update nesting value
0686                INTERPRET4:      
0686   79                     LD   a,c   ; is count zero?
0687   B0                     OR   b   
0688   20 F6                  JR   nz,interpret3   ; if not loop
068A   C1                     POP   bc   ; restore offset into TIB
068B                INTERPRET5:      
068B   CD 81 00               CALL   getchar   ; loop around waiting for character from serial port
068E   FE 20                  CP   $20   ; compare to space
0690   30 14                  JR   nc,interpret6   ; if >= space, if below 20 set cary flag
0692   FE 00                  CP   NUL   ; is it end of string? NUL end of string
0694   28 31                  JR   z,interpret8   
0696   FE 0D                  CP   "\r"   ; carriage return? ascii 13
0698   28 1A                  JR   z,interpret7   ; if anything else its macro/control
069A   FE 08                  CP   CTRL_H   
069C   CA 26 07               JP   z,backSpace_   
069F   FE 0A                  CP   CTRL_J   
06A1   CA 36 07               JP   z,reEdit_   
06A4                INTERPRET5A:      
06A4   18 D2                  JR   interpret2   
06A6                INTERPRET6:      
06A6   21 00 23               LD   hl,TIB   
06A9   09                     ADD   hl,bc   
06AA   77                     LD   (hl),a   ; store the character in textbuf
06AB   03                     INC   bc   
06AC   CD 85 00               CALL   putchar   ; echo character to screen
06AF   CD 85 05               CALL   nesting   
06B2   18 D7                  JR   interpret5   ; wait for next character
06B4                INTERPRET7:      
06B4   21 00 23               LD   hl,TIB   
06B7   09                     ADD   hl,bc   
06B8   36 0D                  LD   (hl),"\r"   ; store the crlf in textbuf
06BA   23                     INC   hl   
06BB   36 0A                  LD   (hl),"\n"   
06BD   23                     INC   hl   
06BE   03                     INC   bc   
06BF   03                     INC   bc   
06C0   CD C4 05               CALL   crlf   ; echo character to screen
06C3   7B                     LD   a,e   ; if zero nesting append and ETX after \r
06C4   B7                     OR   a   
06C5   20 C4                  JR   nz,interpret5   
06C7                INTERPRET8:      
06C7   21 00 23               LD   hl,TIB   
06CA   09                     ADD   hl,bc   
06CB   22 E6 25               LD   (vTIBPtr),hl   
06CE   01 00 23               LD   bc,TIB   
06D1   ED 43 FE 25            LD   (vSavedIP),bc   ; save IP
06D5   ED 73 00 26            LD   (vSavedDSP),sp   ; save Data SP
06D9   FD 22 02 26            LD   (vSavedRSP),iy   ; save Return SP
06DD   DD 22 04 26            LD   (vSavedNext),ix   ; save Next
06E1   0B                     DEC   bc   
06E2                NEXT:        
06E2   03                     INC   bc   ; Increment the IP
06E3   0A                     LD   a,(bc)   ; Get the next character and dispatch
06E4   FE 20                  CP   " "   ; whitespace?
06E6   28 FA                  JR   z,next   ; space? ignore
06E8   38 1B                  JR   c,next1   
06EA   50 59                  LD   de,bc   ; de = token start
06EC                NEXT0:       
06EC   03                     INC   bc   ; bc = first char
06ED   0A                     LD   a,(bc)   
06EE   FE 21                  CP   " "+1   
06F0   30 FA                  JR   nc,next0   
06F2   60 69                  LD   hl,bc   
06F4   B7                     OR   a   
06F5   ED 52                  SBC   hl,de   
06F7   EB                     EX   de,hl   ; hl = tok, de = len
06F8   C5                     PUSH   bc   
06F9   43                     LD   b,e   
06FA   CD 56 07               CALL   hash   
06FD   C1                     POP   bc   
06FE   6F                     LD   l,a   ; index into table
06FF   26 03                  LD   h,msb(opcodes)   ; start address of jump table
0701   6E                     LD   l,(hl)   ; get low jump address
0702   26 04                  LD   h,msb(page4)   ; implementations are on page4
0704   E9                     JP   (hl)   ; Jump to routine
0705                NEXT1:       
0705   FE 00                  CP   NUL   ; end of input string?
0707   28 03                  JR   z,exit   
0709   C3 6C 06               JP   interpret   ; no, other whitespace, macros?
070C                EXIT:        
070C   03                     INC   bc   
070D   60 69                  LD   hl,bc   
070F   E9                     JP   (hl)   
0710                RUN:         
0710   C1                     POP   bc   
0711   0B                     DEC   bc   
0712   DD E9                  JP   (ix)   
0714                ERROR:       
0714   E5                     PUSH   hl   
0715   CD 10 07               CALL   run   
0718   60 45 72 72 6F 72 20 60 20 2E 00 DB   "`Error ` .",0   
0723   C3 6C 06               JP   interpret   
0726                BACKSPACE_:      
0726   79                     LD   a,c   
0727   B0                     OR   b   
0728   CA 78 06               JP   z,interpret2   
072B   0B                     DEC   bc   
072C   CD CB 05               CALL   printStr   
072F   08 20 08 00            .CSTR   "\b \b"   
0733   C3 78 06               JP   interpret2   
0736                REEDIT_:      
0736   CD CB 05               CALL   printStr   
0739   0D 3E 20 00            .CSTR   "\r> "   
073D   21 00 23               LD   hl,TIB   
0740   18 04                  JR   reEdit1   
0742                REEDIT0:      
0742   CD 85 00               CALL   putchar   
0745   23                     INC   hl   
0746                REEDIT1:      
0746   7E                     LD   a,(hl)   
0747   FE 0D                  CP   "\r"   
0749   20 F7                  JR   nz,reEdit0   
074B   11 00 23               LD   de,TIB   
074E   B7                     OR   a   
074F   ED 52                  SBC   hl,de   
0751   44 4D                  LD   bc,hl   
0753   C3 78 06               JP   interpret2   
0756                             ; hash
0756                             ; hl = str
0756                             ; de = len
0756                             ; returns a = hash
0756                HASH:        
0756   AF                     XOR   a   ; hash = zero
0757   B8                     CP   b   ; does b == zero ?
0758   C8                     RET   z   ; yes execute with hash = 0
0759   16 02                  LD   d,msb(pearson)   ; page aligned pearson table
075B                HASH1:       
075B   4E                     LD   c,(hl)   ; c = str[hl++]
075C   23                     INC   hl   
075D   A9                     XOR   c   ; hash = pearson[hash ^ c]
075E   5F                     LD   e,a   
075F   1A                     LD   a,(de)   
0760   10 F9                  DJNZ   hash1   ; loop
0762   C9                     RET      
0763                ANSIPRINTSEQ:      
0763   CD CB 05               CALL   printStr   
0766   1B 5B 00               DB   ESC,"[",0   
0769   C9                     RET      
076A                             ; clears screen and sets cursor to 0,0
076A                ANSICLEARSCREEN:      
076A   CD CB 05               CALL   printStr   
076D   1B 5B                  DB   ESC,"["   
076F   32 4A 00               DB   "2J",0   ; falls through
0772                             ; call ansiPrintStr
0772                             ; .cstr "H"
0772   C9                     RET      
0773                             ; a = 0:toEnd 1:toStart 2:entireLine
0773                ANSICLEARLINE:      
0773   C6 30                  ADD   a,"0"   ; ascii
0775   08                     EX   af,af'   ; save a
0776   CD 63 07               CALL   ansiPrintSeq   
0779   08                     EX   af,af'   ; restore
077A   CD 85 00               CALL   putChar   
077D   3E 4B                  LD   a,"K"   
077F   C3 85 00               JP   putChar   
0782                             ; h = column, l = row
0782                ANSIGOTO:      
0782   D9                     EXX      ; save hl
0783   CD 63 07               CALL   ansiPrintSeq   
0786   D9                     EXX      ; restore hl
0787   7C                     LD   a,h   ; save column
0788   08                     EX   af,af'   
0789   26 00                  LD   h,0   ; print row
078B   CD D2 05               CALL   printNum   
078E   3E 3B                  LD   a,";"   
0790   CD 85 00               CALL   putChar   
0793   08                     EX   af,af'   ; restore column
0794   6C                     LD   l,h   ; print column
0795   26 00                  LD   h,0   
0797   CD D2 05               CALL   printNum   
079A   3E 48                  LD   a,"H"   
079C   C3 85 00               JP   putChar   
079F                             ; h = "A":Up "B":Down "C":Forward "D":Back
079F                             ; l = amount
079F                ANSIMOVE:      
079F   D9                     EXX      ; save hl
07A0   CD 63 07               CALL   ansiPrintSeq   
07A3   D9                     EXX      ; restore hl
07A4   7C                     LD   a,h   
07A5   08                     EX   af,af'   ; save a
07A6   26 00                  LD   h,0   ; print amount
07A8   CD D2 05               CALL   printNum   
07AB   08                     EX   af,af'   ; restore a
07AC   C3 85 00               JP   putChar   ; print direction code
07AF                             ; a = 0:normal 1:bold 2:low 4:underline 5:blink 7:reverse
07AF                ANSITEXTSTYLE:      
07AF   C6 30                  ADD   a,"0"   ; ascii
07B1   08                     EX   af,af'   ; save a
07B2   CD 63 07               CALL   ansiPrintSeq   
07B5   08                     EX   af,af'   ; restore
07B6   CD 85 00               CALL   putChar   
07B9   3E 6D                  LD   a,"m"   
07BB   C3 85 00               JP   putChar   
07BE                             ; a = "h":show "l":hide
07BE                ANSICURSORSHOW:      
07BE   08                     EX   af,af'   ; save a
07BF   CD CB 05               CALL   printStr   
07C2   1B 5B                  DB   ESC,"["   
07C4   3F 32 35 00            DB   "?25",0   
07C8   08                     EX   af,af'   ; restore
07C9   C3 85 00               JP   putChar   
07CC                             ; 
2000                          .ORG   RAMSTART   
2000                DSTACK_SIZE:   EQU   $100   ; Data stack size
2000                RSTACK_SIZE:   EQU   $100   ; Return stack size
2000                NAMES_SIZE:   EQU   $100   ; Arg names size
2000                TIBSIZE:   EQU   $100   ; 256 bytes
2000                BUFSIZE:   EQU   $100   ; 256 bytes, wraps
2000                          ALIGN   $100   
2000                          DS   DSTACK_SIZE   
2100                STACK:       
2100                DSTACK:      
2100                RSTACK:      
2100                          DS   RSTACK_SIZE   
2200                NAMES:       
2200                          DS   NAMES_SIZE   
2300                          ALIGN   $100   
2300                TIB:      DS   TIBSIZE   ; must be one page, lsb of vTIBPtr is length and wraps around
2400                          ALIGN   $100   
2400                BUFFER:   DS   BUFSIZE   ; must be one page, lsb of vBufPtr is length and wraps around
2500                          ALIGN   $100   
2500                VARS:        
2500                          DS   26 * 2 * 4   ; 52 vars, 3 bytes, RST LO HI CHAR
25D0                RESTARTS:      
25D0                RST08:    DS   2   
25D2                RST10:    DS   2   
25D4                RST18:    DS   2   
25D6                RST20:    DS   2   
25D8                RST28:    DS   2   
25DA                RST30:    DS   2   ; 
25DC                BAUD:     DS   2   ; 
25DE                INTVEC:   DS   2   ; 
25E0                NMIVEC:   DS   2   ; 
25E2                GETCVEC:   DS   2   ; 
25E4                PUTCVEC:   DS   2   ; 
25E6                SYSVARS:      
25E6                             ; initialised sys variables (preserved)
25E6                VTIBPTR:   DS   2   
25E8                VBUFPTR:   DS   2   
25EA                VHEAPPTR:   DS   2   
25EC                VNAMESPTR:   DS   2   
25EE                VRECURPTR:   DS   2   
25F0                VDATAWIDTH:   DS   1   
25F1                VNUMBASE:   DS   1   
25F2                VHEXPREFIX:   DS   1   
25F3                VECHO:    DS   1   
25F4                VSTRMODE:   DS   1   
25F5                          DS   1   
25F6                          DS   1   
25F7                          DS   1   
25F8                          DS   1   
25F9                          DS   1   
25FA                             ; uninitialised sys variables (preserved)
25FA                VPOINTER:   DS   2   ; 
25FC                VREMAIN:   DS   2   ; 
25FE                VSAVEDIP:   DS   2   ; 
2600                VSAVEDDSP:   DS   2   ; 
2602                VSAVEDRSP:   DS   2   ; 
2604                VSAVEDNEXT:   DS   2   ; 
2606                VSAVEDBP:   DS   2   ; 
2608                             ; uninitialised sys variables (unpreserved)
2608                VTEMP1:   DS   2   ; 
260A                VTEMP2:   DS   2   ; 
260C                VTEMP3:   DS   2   ; 
260E                          DS   2   ; 
2610                TBPTR:    DS   2   ; reserved for tests
2612                TITLEBUF:   DS   20   
2626                HEAP:        


TEC_1:              0001 DEFINED AT LINE 1 IN constants.asm
RC2014:             0000 DEFINED AT LINE 2 IN constants.asm
EXTENDED:           0000 DEFINED AT LINE 4 IN constants.asm
LOADER:             0000 DEFINED AT LINE 20 IN constants.asm
BITBANG:            0000 DEFINED AT LINE 21 IN constants.asm
ROMSTART:           0000 DEFINED AT LINE 23 IN constants.asm
                    > USED AT LINE 100 IN IOSerial.asm
                    > USED AT LINE 105 IN IOSerial.asm
                    > USED AT LINE 112 IN IOSerial.asm
                    > USED AT LINE 119 IN IOSerial.asm
                    > USED AT LINE 126 IN IOSerial.asm
                    > USED AT LINE 133 IN IOSerial.asm
                    > USED AT LINE 140 IN IOSerial.asm
                    > USED AT LINE 147 IN IOSerial.asm
                    > USED AT LINE 153 IN IOSerial.asm
                    > USED AT LINE 195 IN IOSerial.asm
                    > USED AT LINE 47 IN MAIN.asm
RAMSTART:           2000 DEFINED AT LINE 24 IN constants.asm
                    > USED AT LINE 12
ROMSIZE:            2000 DEFINED AT LINE 25 IN constants.asm
RAMSIZE:            2000 DEFINED AT LINE 26 IN constants.asm
CONTROL:            0080 DEFINED AT LINE 22 IN IOSerial.asm
                    > USED AT LINE 471 IN IOSerial.asm
                    > USED AT LINE 493 IN IOSerial.asm
STATUS:             0080 DEFINED AT LINE 23 IN IOSerial.asm
                    > USED AT LINE 304 IN IOSerial.asm
                    > USED AT LINE 317 IN IOSerial.asm
TDR:                0081 DEFINED AT LINE 24 IN IOSerial.asm
                    > USED AT LINE 309 IN IOSerial.asm
RDR:                0081 DEFINED AT LINE 25 IN IOSerial.asm
                    > USED AT LINE 321 IN IOSerial.asm
MRESET:             0003 DEFINED AT LINE 32 IN IOSerial.asm
                    > USED AT LINE 470 IN IOSerial.asm
DIV_64:             0002 DEFINED AT LINE 35 IN IOSerial.asm
                    > USED AT LINE 492 IN IOSerial.asm
F7E2:               0000 DEFINED AT LINE 39 IN IOSerial.asm
F7O2:               0004 DEFINED AT LINE 40 IN IOSerial.asm
F7E1:               0008 DEFINED AT LINE 41 IN IOSerial.asm
F7O1:               000C DEFINED AT LINE 42 IN IOSerial.asm
F8N2:               0010 DEFINED AT LINE 43 IN IOSerial.asm
                    > USED AT LINE 492 IN IOSerial.asm
F8N1:               0014 DEFINED AT LINE 44 IN IOSerial.asm
F8E1:               0018 DEFINED AT LINE 45 IN IOSerial.asm
F8O1:               001C DEFINED AT LINE 46 IN IOSerial.asm
RTSLID:             0000 DEFINED AT LINE 50 IN IOSerial.asm
                    > USED AT LINE 492 IN IOSerial.asm
RTSLIE:             0020 DEFINED AT LINE 51 IN IOSerial.asm
RTSHID:             0040 DEFINED AT LINE 52 IN IOSerial.asm
RTSLIDB:            0060 DEFINED AT LINE 53 IN IOSerial.asm
RIE:                0080 DEFINED AT LINE 57 IN IOSerial.asm
RDRF:               0000 DEFINED AT LINE 61 IN IOSerial.asm
TDRE:               0001 DEFINED AT LINE 62 IN IOSerial.asm
DCD:                0002 DEFINED AT LINE 63 IN IOSerial.asm
CTS:                0003 DEFINED AT LINE 64 IN IOSerial.asm
FE:                 0004 DEFINED AT LINE 65 IN IOSerial.asm
OVRN:               0005 DEFINED AT LINE 66 IN IOSerial.asm
PE:                 0006 DEFINED AT LINE 67 IN IOSerial.asm
IRQ:                0007 DEFINED AT LINE 68 IN IOSerial.asm
KEYBUF:             0000 DEFINED AT LINE 76 IN IOSerial.asm
SCAN:               0001 DEFINED AT LINE 77 IN IOSerial.asm
DISPLY:             0002 DEFINED AT LINE 78 IN IOSerial.asm
PORT3:              0003 DEFINED AT LINE 79 IN IOSerial.asm
PORT4:              0004 DEFINED AT LINE 80 IN IOSerial.asm
PORT5:              0005 DEFINED AT LINE 81 IN IOSerial.asm
PORT6:              0006 DEFINED AT LINE 82 IN IOSerial.asm
PORT7:              0007 DEFINED AT LINE 83 IN IOSerial.asm
ESC:                001B DEFINED AT LINE 26 IN MAIN.asm
                    > USED AT LINE 77 IN MAIN.asm
                    > USED AT LINE 3 IN ansi.asm
                    > USED AT LINE 9 IN ansi.asm
                    > USED AT LINE 70 IN ansi.asm
CR:                 000D DEFINED AT LINE 97 IN IOSerial.asm
LF:                 000A DEFINED AT LINE 98 IN IOSerial.asm
RSTVEC:             0000 DEFINED AT LINE 102 IN IOSerial.asm
SEVENSEGMENT:       0040 DEFINED AT LINE 158 IN IOSerial.asm
PWRUP:              0050 DEFINED AT LINE 180 IN IOSerial.asm
                    > USED AT LINE 476 IN IOSerial.asm
BITIME:             0053 DEFINED AT LINE 182 IN IOSerial.asm
BITIM1:             0058 DEFINED AT LINE 186 IN IOSerial.asm
                    > USED AT LINE 188 IN IOSerial.asm
INTRET:             005F DEFINED AT LINE 191 IN IOSerial.asm
                    > USED AT LINE 452 IN IOSerial.asm
TXDATA:             006B DEFINED AT LINE 299 IN IOSerial.asm
                    > USED AT LINE 464 IN IOSerial.asm
TXCHAR:             006B DEFINED AT LINE 300 IN IOSerial.asm
TXCHAR1:            006D DEFINED AT LINE 303 IN IOSerial.asm
                    > USED AT LINE 307 IN IOSerial.asm
RXDATA:             0078 DEFINED AT LINE 315 IN IOSerial.asm
                    > USED AT LINE 462 IN IOSerial.asm
RXCHAR:             0078 DEFINED AT LINE 316 IN IOSerial.asm
                    > USED AT LINE 320 IN IOSerial.asm
GETCHAR:            0081 DEFINED AT LINE 440 IN IOSerial.asm
                    > USED AT LINE 646 IN MAIN.asm
PUTCHAR:            0085 DEFINED AT LINE 444 IN IOSerial.asm
                    > USED AT LINE 368 IN MAIN.asm
                    > USED AT LINE 668 IN MAIN.asm
                    > USED AT LINE 761 IN MAIN.asm
                    > USED AT LINE 21 IN ansi.asm
                    > USED AT LINE 23 IN ansi.asm
                    > USED AT LINE 35 IN ansi.asm
                    > USED AT LINE 41 IN ansi.asm
                    > USED AT LINE 54 IN ansi.asm
                    > USED AT LINE 62 IN ansi.asm
                    > USED AT LINE 64 IN ansi.asm
                    > USED AT LINE 73 IN ansi.asm
RESET:              008B DEFINED AT LINE 450 IN IOSerial.asm
                    > USED AT LINE 103 IN IOSerial.asm
TRUE:               00-1 DEFINED AT LINE 15 IN MAIN.asm
                    > USED AT LINE 66 IN MAIN.asm
                    > USED AT LINE 536 IN MAIN.asm
FALSE:              0000 DEFINED AT LINE 16 IN MAIN.asm
                    > USED AT LINE 67 IN MAIN.asm
                    > USED AT LINE 533 IN MAIN.asm
NUL:                0000 DEFINED AT LINE 17 IN MAIN.asm
                    > USED AT LINE 62 IN MAIN.asm
                    > USED AT LINE 649 IN MAIN.asm
                    > USED AT LINE 726 IN MAIN.asm
DQ:                 0022 DEFINED AT LINE 18 IN MAIN.asm
                    > USED AT LINE 451 IN MAIN.asm
CTRL_C:             0003 DEFINED AT LINE 19 IN MAIN.asm
CTRL_E:             0005 DEFINED AT LINE 20 IN MAIN.asm
CTRL_H:             0008 DEFINED AT LINE 21 IN MAIN.asm
                    > USED AT LINE 654 IN MAIN.asm
CTRL_J:             000A DEFINED AT LINE 22 IN MAIN.asm
                    > USED AT LINE 656 IN MAIN.asm
CTRL_L:             000C DEFINED AT LINE 23 IN MAIN.asm
CTRL_P:             0010 DEFINED AT LINE 24 IN MAIN.asm
CTRL_S:             0013 DEFINED AT LINE 25 IN MAIN.asm
ISYSVARS:           0180 DEFINED AT LINE 57 IN MAIN.asm
                    > USED AT LINE 587 IN MAIN.asm
TITLESTR:           0192 DEFINED AT LINE 76 IN MAIN.asm
                    > USED AT LINE 562 IN MAIN.asm
                    > USED AT LINE 581 IN MAIN.asm
PEARSON:            0200 DEFINED AT LINE 82 IN MAIN.asm
OPCODES:            0300 DEFINED AT LINE 93 IN MAIN.asm
PAGE4:              0400 DEFINED AT LINE 106 IN MAIN.asm
RLA_:               0400 DEFINED AT LINE 108 IN MAIN.asm
OUTI_:              0400 DEFINED AT LINE 109 IN MAIN.asm
INDR_:              0400 DEFINED AT LINE 110 IN MAIN.asm
IND_:               0400 DEFINED AT LINE 111 IN MAIN.asm
RL_:                0400 DEFINED AT LINE 112 IN MAIN.asm
CP_:                0400 DEFINED AT LINE 113 IN MAIN.asm
EX_:                0400 DEFINED AT LINE 114 IN MAIN.asm
IN_:                0400 DEFINED AT LINE 115 IN MAIN.asm
EI_:                0400 DEFINED AT LINE 116 IN MAIN.asm
INC_:               0400 DEFINED AT LINE 117 IN MAIN.asm
LDIR_:              0400 DEFINED AT LINE 118 IN MAIN.asm
DEC_:               0400 DEFINED AT LINE 119 IN MAIN.asm
ADD_:               0400 DEFINED AT LINE 120 IN MAIN.asm
                    > USED AT LINE 95 IN MAIN.asm
SLA_:               0400 DEFINED AT LINE 121 IN MAIN.asm
EXX_:               0400 DEFINED AT LINE 122 IN MAIN.asm
RRC_:               0400 DEFINED AT LINE 123 IN MAIN.asm
OR_:                0400 DEFINED AT LINE 124 IN MAIN.asm
IM_:                0400 DEFINED AT LINE 125 IN MAIN.asm
OTDR_:              0400 DEFINED AT LINE 126 IN MAIN.asm
DI_:                0400 DEFINED AT LINE 127 IN MAIN.asm
JR_:                0400 DEFINED AT LINE 128 IN MAIN.asm
SRA_:               0400 DEFINED AT LINE 129 IN MAIN.asm
NEG_:               0400 DEFINED AT LINE 130 IN MAIN.asm
CCF_:               0400 DEFINED AT LINE 131 IN MAIN.asm
AND_:               0400 DEFINED AT LINE 132 IN MAIN.asm
RES_:               0400 DEFINED AT LINE 133 IN MAIN.asm
CPDR_:              0400 DEFINED AT LINE 134 IN MAIN.asm
SCF_:               0400 DEFINED AT LINE 135 IN MAIN.asm
RST_:               0400 DEFINED AT LINE 136 IN MAIN.asm
POP_:               0400 DEFINED AT LINE 137 IN MAIN.asm
RETI_:              0400 DEFINED AT LINE 138 IN MAIN.asm
LDD_:               0400 DEFINED AT LINE 139 IN MAIN.asm
OUTD_:              0400 DEFINED AT LINE 140 IN MAIN.asm
                    > USED AT LINE 98 IN MAIN.asm
RRD_:               0400 DEFINED AT LINE 141 IN MAIN.asm
                    > USED AT LINE 98 IN MAIN.asm
ADC_:               0400 DEFINED AT LINE 142 IN MAIN.asm
RETN_:              0400 DEFINED AT LINE 143 IN MAIN.asm
RLC_:               0400 DEFINED AT LINE 144 IN MAIN.asm
SUB_:               0400 DEFINED AT LINE 145 IN MAIN.asm
CPI_:               0400 DEFINED AT LINE 146 IN MAIN.asm
CALL_:              0400 DEFINED AT LINE 147 IN MAIN.asm
OUT_:               0400 DEFINED AT LINE 148 IN MAIN.asm
XOR_:               0400 DEFINED AT LINE 149 IN MAIN.asm
RLD_:               0400 DEFINED AT LINE 150 IN MAIN.asm
DJNZ_:              0400 DEFINED AT LINE 151 IN MAIN.asm
CPIR_:              0400 DEFINED AT LINE 152 IN MAIN.asm
SET_:               0400 DEFINED AT LINE 153 IN MAIN.asm
                    > USED AT LINE 95 IN MAIN.asm
PUSH_:              0400 DEFINED AT LINE 154 IN MAIN.asm
INI_:               0400 DEFINED AT LINE 155 IN MAIN.asm
RRA_:               0400 DEFINED AT LINE 156 IN MAIN.asm
BIT_:               0400 DEFINED AT LINE 157 IN MAIN.asm
LDDR_:              0400 DEFINED AT LINE 158 IN MAIN.asm
SLL_:               0400 DEFINED AT LINE 159 IN MAIN.asm
DAA_:               0400 DEFINED AT LINE 160 IN MAIN.asm
OTIR_:              0400 DEFINED AT LINE 161 IN MAIN.asm
                    > USED AT LINE 100 IN MAIN.asm
CPD_:               0400 DEFINED AT LINE 162 IN MAIN.asm
RRCA_:              0400 DEFINED AT LINE 163 IN MAIN.asm
INIR_:              0400 DEFINED AT LINE 164 IN MAIN.asm
CPL_:               0400 DEFINED AT LINE 165 IN MAIN.asm
RR_:                0400 DEFINED AT LINE 166 IN MAIN.asm
JP_:                0400 DEFINED AT LINE 167 IN MAIN.asm
HALT_:              0400 DEFINED AT LINE 168 IN MAIN.asm
SBC_:               0400 DEFINED AT LINE 169 IN MAIN.asm
NOP_:               0400 DEFINED AT LINE 170 IN MAIN.asm
RLCA_:              0400 DEFINED AT LINE 171 IN MAIN.asm
RET_:               0400 DEFINED AT LINE 172 IN MAIN.asm
SRL_:               0400 DEFINED AT LINE 173 IN MAIN.asm
LDI_:               0400 DEFINED AT LINE 174 IN MAIN.asm
LD_:                0401 DEFINED AT LINE 177 IN MAIN.asm
NUM:                0500 DEFINED AT LINE 323 IN MAIN.asm
NUM0:               0509 DEFINED AT LINE 329 IN MAIN.asm
                    > USED AT LINE 327 IN MAIN.asm
NUM1:               050A DEFINED AT LINE 331 IN MAIN.asm
                    > USED AT LINE 348 IN MAIN.asm
NUM2:               0522 DEFINED AT LINE 349 IN MAIN.asm
                    > USED AT LINE 334 IN MAIN.asm
                    > USED AT LINE 336 IN MAIN.asm
NUM3:               052D DEFINED AT LINE 357 IN MAIN.asm
                    > USED AT LINE 352 IN MAIN.asm
PUTSTR0:            0530 DEFINED AT LINE 367 IN MAIN.asm
                    > USED AT LINE 373 IN MAIN.asm
PUTSTR:             0534 DEFINED AT LINE 370 IN MAIN.asm
                    > USED AT LINE 501 IN MAIN.asm
                    > USED AT LINE 517 IN MAIN.asm
                    > USED AT LINE 613 IN MAIN.asm
FORMATDEC0:         0539 DEFINED AT LINE 379 IN MAIN.asm
                    > USED AT LINE 509 IN MAIN.asm
FORMATDEC:          053C DEFINED AT LINE 386 IN MAIN.asm
FORMATDEC2:         054C DEFINED AT LINE 400 IN MAIN.asm
                    > USED AT LINE 388 IN MAIN.asm
FORMATDEC4:         056C DEFINED AT LINE 414 IN MAIN.asm
                    > USED AT LINE 403 IN MAIN.asm
                    > USED AT LINE 405 IN MAIN.asm
                    > USED AT LINE 407 IN MAIN.asm
                    > USED AT LINE 409 IN MAIN.asm
                    > USED AT LINE 412 IN MAIN.asm
FORMATDEC5:         056E DEFINED AT LINE 416 IN MAIN.asm
                    > USED AT LINE 419 IN MAIN.asm
FORMATDEC6:         057E DEFINED AT LINE 428 IN MAIN.asm
                    > USED AT LINE 423 IN MAIN.asm
FORMATDEC7:         057F DEFINED AT LINE 430 IN MAIN.asm
                    > USED AT LINE 427 IN MAIN.asm
NESTING:            0585 DEFINED AT LINE 448 IN MAIN.asm
                    > USED AT LINE 635 IN MAIN.asm
                    > USED AT LINE 669 IN MAIN.asm
NESTING0:           0593 DEFINED AT LINE 456 IN MAIN.asm
                    > USED AT LINE 450 IN MAIN.asm
                    > USED AT LINE 452 IN MAIN.asm
                    > USED AT LINE 454 IN MAIN.asm
NESTING1A:          059A DEFINED AT LINE 461 IN MAIN.asm
                    > USED AT LINE 458 IN MAIN.asm
NESTING1:           059D DEFINED AT LINE 464 IN MAIN.asm
                    > USED AT LINE 455 IN MAIN.asm
NESTING2:           05AC DEFINED AT LINE 473 IN MAIN.asm
                    > USED AT LINE 468 IN MAIN.asm
                    > USED AT LINE 470 IN MAIN.asm
NESTING3:           05AE DEFINED AT LINE 476 IN MAIN.asm
                    > USED AT LINE 472 IN MAIN.asm
NESTING4:           05B9 DEFINED AT LINE 483 IN MAIN.asm
                    > USED AT LINE 478 IN MAIN.asm
                    > USED AT LINE 480 IN MAIN.asm
PROMPT:             05BB DEFINED AT LINE 487 IN MAIN.asm
                    > USED AT LINE 617 IN MAIN.asm
CRLF:               05C4 DEFINED AT LINE 492 IN MAIN.asm
                    > USED AT LINE 682 IN MAIN.asm
PRINTSTR:           05CB DEFINED AT LINE 499 IN MAIN.asm
                    > USED AT LINE 488 IN MAIN.asm
                    > USED AT LINE 493 IN MAIN.asm
                    > USED AT LINE 751 IN MAIN.asm
                    > USED AT LINE 756 IN MAIN.asm
                    > USED AT LINE 2 IN ansi.asm
                    > USED AT LINE 8 IN ansi.asm
                    > USED AT LINE 69 IN ansi.asm
PRINTNUM:           05D2 DEFINED AT LINE 507 IN MAIN.asm
                    > USED AT LINE 33 IN ansi.asm
                    > USED AT LINE 39 IN ansi.asm
                    > USED AT LINE 52 IN ansi.asm
STRINGCOMPARE:      05EB DEFINED AT LINE 522 IN MAIN.asm
STRINGCOMPARE1:     05EB DEFINED AT LINE 523 IN MAIN.asm
                    > USED AT LINE 531 IN MAIN.asm
STRINGCOMPARE2:     05F6 DEFINED AT LINE 532 IN MAIN.asm
                    > USED AT LINE 526 IN MAIN.asm
STRINGCOMPARE3:     05FB DEFINED AT LINE 535 IN MAIN.asm
                    > USED AT LINE 528 IN MAIN.asm
STRINGCOMPARE4:     05FE DEFINED AT LINE 537 IN MAIN.asm
                    > USED AT LINE 534 IN MAIN.asm
STRINGLENGTH:       0600 DEFINED AT LINE 544 IN MAIN.asm
STRINGLENGTH1:      0605 DEFINED AT LINE 547 IN MAIN.asm
                    > USED AT LINE 553 IN MAIN.asm
STRINGLENGTH2:      0607 DEFINED AT LINE 550 IN MAIN.asm
                    > USED AT LINE 546 IN MAIN.asm
STRINGLENGTH3:      060B DEFINED AT LINE 554 IN MAIN.asm
INIT:               060C DEFINED AT LINE 561 IN MAIN.asm
                    > USED AT LINE 610 IN MAIN.asm
INIT1:              0614 DEFINED AT LINE 565 IN MAIN.asm
                    > USED AT LINE 571 IN MAIN.asm
WARMINIT:           061C DEFINED AT LINE 573 IN MAIN.asm
COLDBOOT0:          062F DEFINED AT LINE 580 IN MAIN.asm
                    > USED AT LINE 568 IN MAIN.asm
                    > USED AT LINE 606 IN MAIN.asm
COLDINIT:           0639 DEFINED AT LINE 586 IN MAIN.asm
COLDBOOT1:          064A DEFINED AT LINE 595 IN MAIN.asm
                    > USED AT LINE 598 IN MAIN.asm
COLDSTART:          0657 DEFINED AT LINE 604 IN MAIN.asm
START:              0660 DEFINED AT LINE 608 IN MAIN.asm
                    > USED AT LINE 7
START1:             0666 DEFINED AT LINE 611 IN MAIN.asm
                    > USED AT LINE 578 IN MAIN.asm
                    > USED AT LINE 607 IN MAIN.asm
INTERPRET:          066C DEFINED AT LINE 615 IN MAIN.asm
                    > USED AT LINE 728 IN MAIN.asm
                    > USED AT LINE 744 IN MAIN.asm
INTERPRET2:         0678 DEFINED AT LINE 623 IN MAIN.asm
                    > USED AT LINE 660 IN MAIN.asm
                    > USED AT LINE 749 IN MAIN.asm
                    > USED AT LINE 753 IN MAIN.asm
                    > USED AT LINE 771 IN MAIN.asm
INTERPRET3:         0680 DEFINED AT LINE 631 IN MAIN.asm
                    > USED AT LINE 641 IN MAIN.asm
INTERPRET4:         0686 DEFINED AT LINE 637 IN MAIN.asm
                    > USED AT LINE 629 IN MAIN.asm
INTERPRET5:         068B DEFINED AT LINE 644 IN MAIN.asm
                    > USED AT LINE 670 IN MAIN.asm
                    > USED AT LINE 685 IN MAIN.asm
INTERPRET5A:        06A4 DEFINED AT LINE 659 IN MAIN.asm
INTERPRET6:         06A6 DEFINED AT LINE 662 IN MAIN.asm
                    > USED AT LINE 648 IN MAIN.asm
INTERPRET7:         06B4 DEFINED AT LINE 672 IN MAIN.asm
                    > USED AT LINE 652 IN MAIN.asm
INTERPRET8:         06C7 DEFINED AT LINE 687 IN MAIN.asm
                    > USED AT LINE 650 IN MAIN.asm
NEXT:               06E2 DEFINED AT LINE 700 IN MAIN.asm
                    > USED AT LINE 600 IN MAIN.asm
                    > USED AT LINE 704 IN MAIN.asm
NEXT0:              06EC DEFINED AT LINE 707 IN MAIN.asm
                    > USED AT LINE 711 IN MAIN.asm
NEXT1:              0705 DEFINED AT LINE 725 IN MAIN.asm
                    > USED AT LINE 705 IN MAIN.asm
EXIT:               070C DEFINED AT LINE 730 IN MAIN.asm
                    > USED AT LINE 727 IN MAIN.asm
RUN:                0710 DEFINED AT LINE 735 IN MAIN.asm
                    > USED AT LINE 742 IN MAIN.asm
ERROR:              0714 DEFINED AT LINE 740 IN MAIN.asm
BACKSPACE_:         0726 DEFINED AT LINE 746 IN MAIN.asm
                    > USED AT LINE 655 IN MAIN.asm
REEDIT_:            0736 DEFINED AT LINE 755 IN MAIN.asm
                    > USED AT LINE 657 IN MAIN.asm
REEDIT0:            0742 DEFINED AT LINE 760 IN MAIN.asm
                    > USED AT LINE 766 IN MAIN.asm
REEDIT1:            0746 DEFINED AT LINE 763 IN MAIN.asm
                    > USED AT LINE 759 IN MAIN.asm
HASH:               0756 DEFINED AT LINE 777 IN MAIN.asm
                    > USED AT LINE 718 IN MAIN.asm
HASH1:              075B DEFINED AT LINE 782 IN MAIN.asm
                    > USED AT LINE 788 IN MAIN.asm
ANSIPRINTSEQ:       0763 DEFINED AT LINE 1 IN ansi.asm
                    > USED AT LINE 19 IN ansi.asm
                    > USED AT LINE 28 IN ansi.asm
                    > USED AT LINE 47 IN ansi.asm
                    > USED AT LINE 60 IN ansi.asm
ANSICLEARSCREEN:    076A DEFINED AT LINE 7 IN ansi.asm
ANSICLEARLINE:      0773 DEFINED AT LINE 16 IN ansi.asm
ANSIGOTO:           0782 DEFINED AT LINE 26 IN ansi.asm
ANSIMOVE:           079F DEFINED AT LINE 45 IN ansi.asm
ANSITEXTSTYLE:      07AF DEFINED AT LINE 57 IN ansi.asm
ANSICURSORSHOW:     07BE DEFINED AT LINE 67 IN ansi.asm
DSTACK_SIZE:        0100 DEFINED AT LINE 1 IN ram.asm
                    > USED AT LINE 8 IN ram.asm
RSTACK_SIZE:        0100 DEFINED AT LINE 2 IN ram.asm
                    > USED AT LINE 13 IN ram.asm
NAMES_SIZE:         0100 DEFINED AT LINE 3 IN ram.asm
                    > USED AT LINE 15 IN ram.asm
TIBSIZE:            0100 DEFINED AT LINE 4 IN ram.asm
                    > USED AT LINE 18 IN ram.asm
BUFSIZE:            0100 DEFINED AT LINE 5 IN ram.asm
                    > USED AT LINE 21 IN ram.asm
STACK:              2100 DEFINED AT LINE 9 IN ram.asm
                    > USED AT LINE 451 IN IOSerial.asm
                    > USED AT LINE 6
                    > USED AT LINE 601 IN MAIN.asm
                    > USED AT LINE 605 IN MAIN.asm
                    > USED AT LINE 609 IN MAIN.asm
DSTACK:             2100 DEFINED AT LINE 10 IN ram.asm
RSTACK:             2100 DEFINED AT LINE 12 IN ram.asm
NAMES:              2200 DEFINED AT LINE 14 IN ram.asm
                    > USED AT LINE 61 IN MAIN.asm
TIB:                2300 DEFINED AT LINE 18 IN ram.asm
                    > USED AT LINE 58 IN MAIN.asm
                    > USED AT LINE 620 IN MAIN.asm
                    > USED AT LINE 628 IN MAIN.asm
                    > USED AT LINE 664 IN MAIN.asm
                    > USED AT LINE 674 IN MAIN.asm
                    > USED AT LINE 689 IN MAIN.asm
                    > USED AT LINE 692 IN MAIN.asm
                    > USED AT LINE 758 IN MAIN.asm
                    > USED AT LINE 767 IN MAIN.asm
BUFFER:             2400 DEFINED AT LINE 21 IN ram.asm
                    > USED AT LINE 59 IN MAIN.asm
                    > USED AT LINE 515 IN MAIN.asm
VARS:               2500 DEFINED AT LINE 24 IN ram.asm
                    > USED AT LINE 592 IN MAIN.asm
RESTARTS:           25D0 DEFINED AT LINE 26 IN ram.asm
RST08:              25D0 DEFINED AT LINE 28 IN ram.asm
                    > USED AT LINE 107 IN IOSerial.asm
                    > USED AT LINE 453 IN IOSerial.asm
RST10:              25D2 DEFINED AT LINE 29 IN ram.asm
                    > USED AT LINE 114 IN IOSerial.asm
                    > USED AT LINE 454 IN IOSerial.asm
RST18:              25D4 DEFINED AT LINE 30 IN ram.asm
                    > USED AT LINE 121 IN IOSerial.asm
                    > USED AT LINE 455 IN IOSerial.asm
RST20:              25D6 DEFINED AT LINE 31 IN ram.asm
                    > USED AT LINE 128 IN IOSerial.asm
                    > USED AT LINE 456 IN IOSerial.asm
RST28:              25D8 DEFINED AT LINE 32 IN ram.asm
                    > USED AT LINE 135 IN IOSerial.asm
                    > USED AT LINE 457 IN IOSerial.asm
RST30:              25DA DEFINED AT LINE 33 IN ram.asm
                    > USED AT LINE 142 IN IOSerial.asm
                    > USED AT LINE 458 IN IOSerial.asm
BAUD:               25DC DEFINED AT LINE 34 IN ram.asm
INTVEC:             25DE DEFINED AT LINE 35 IN ram.asm
                    > USED AT LINE 149 IN IOSerial.asm
                    > USED AT LINE 459 IN IOSerial.asm
NMIVEC:             25E0 DEFINED AT LINE 36 IN ram.asm
                    > USED AT LINE 197 IN IOSerial.asm
                    > USED AT LINE 460 IN IOSerial.asm
GETCVEC:            25E2 DEFINED AT LINE 37 IN ram.asm
                    > USED AT LINE 441 IN IOSerial.asm
                    > USED AT LINE 463 IN IOSerial.asm
PUTCVEC:            25E4 DEFINED AT LINE 38 IN ram.asm
                    > USED AT LINE 446 IN IOSerial.asm
                    > USED AT LINE 465 IN IOSerial.asm
SYSVARS:            25E6 DEFINED AT LINE 40 IN ram.asm
                    > USED AT LINE 588 IN MAIN.asm
VTIBPTR:            25E6 DEFINED AT LINE 44 IN ram.asm
                    > USED AT LINE 621 IN MAIN.asm
                    > USED AT LINE 691 IN MAIN.asm
VBUFPTR:            25E8 DEFINED AT LINE 45 IN ram.asm
                    > USED AT LINE 508 IN MAIN.asm
                    > USED AT LINE 514 IN MAIN.asm
                    > USED AT LINE 516 IN MAIN.asm
VHEAPPTR:           25EA DEFINED AT LINE 46 IN ram.asm
VNAMESPTR:          25EC DEFINED AT LINE 47 IN ram.asm
VRECURPTR:          25EE DEFINED AT LINE 48 IN ram.asm
VDATAWIDTH:         25F0 DEFINED AT LINE 49 IN ram.asm
VNUMBASE:           25F1 DEFINED AT LINE 50 IN ram.asm
VHEXPREFIX:         25F2 DEFINED AT LINE 51 IN ram.asm
VECHO:              25F3 DEFINED AT LINE 52 IN ram.asm
VSTRMODE:           25F4 DEFINED AT LINE 53 IN ram.asm
VPOINTER:           25FA DEFINED AT LINE 62 IN ram.asm
VREMAIN:            25FC DEFINED AT LINE 63 IN ram.asm
VSAVEDIP:           25FE DEFINED AT LINE 65 IN ram.asm
                    > USED AT LINE 574 IN MAIN.asm
                    > USED AT LINE 694 IN MAIN.asm
VSAVEDDSP:          2600 DEFINED AT LINE 66 IN ram.asm
                    > USED AT LINE 575 IN MAIN.asm
                    > USED AT LINE 695 IN MAIN.asm
VSAVEDRSP:          2602 DEFINED AT LINE 67 IN ram.asm
                    > USED AT LINE 576 IN MAIN.asm
                    > USED AT LINE 696 IN MAIN.asm
VSAVEDNEXT:         2604 DEFINED AT LINE 68 IN ram.asm
                    > USED AT LINE 577 IN MAIN.asm
                    > USED AT LINE 697 IN MAIN.asm
VSAVEDBP:           2606 DEFINED AT LINE 69 IN ram.asm
VTEMP1:             2608 DEFINED AT LINE 73 IN ram.asm
VTEMP2:             260A DEFINED AT LINE 74 IN ram.asm
VTEMP3:             260C DEFINED AT LINE 75 IN ram.asm
TBPTR:              2610 DEFINED AT LINE 77 IN ram.asm
TITLEBUF:           2612 DEFINED AT LINE 79 IN ram.asm
                    > USED AT LINE 563 IN MAIN.asm
                    > USED AT LINE 582 IN MAIN.asm
                    > USED AT LINE 612 IN MAIN.asm
HEAP:               2626 DEFINED AT LINE 81 IN ram.asm
                    > USED AT LINE 60 IN MAIN.asm
